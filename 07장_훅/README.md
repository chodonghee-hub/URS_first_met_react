# 7강

## [7.1] 훅이란 무엇인가?

### Hook

- 리액트의 state와 생명주기 기능에 갈고리를 걸어 **_원하는 시점에 정해진 함수를 실행되도록 만든 것_**
- 훅의 이름은 모두 **_use로 시작_** 한다
- 개발자 마음대로 이름을 지을 수 있지만 훅의 규칙에 따라 이름 앞에 use를 붙여서 훅이라는 것을 나타내주어야 한다

## [7.2] useState

### useState

- 가장 대표적이고 많이 사용되는 훅
- state를 사용하기 위한 훅
- useState를 호출할 때 **_초기값_** 이 들어가야한다
- 생성된 변수는 **_set함수를 이용하여 값을 변경_** 한다
- set함수를 사용하면서 **_재랜더링_** 이 되고 **_변경된 값이 화면에 표시된다_**

```jsx
const [변수명, set함수명] = useState(초기값);
```

## [7.3] useEffect

### useEffect

- **_Side-effect_** 를 수행하기 위한 Hook
- 리액트에서 Side-effect는 **_효과, 영향을 뜻하는 effect의 의미에 가깝다 ( ex. 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 작업 )_**
- 특히 다른 컴포넌트에 영향을 미칠 수 있으며, 랜더링 중에는 작업이 완료될 수 없기 때문이다
- 생명주기 함수와 동일한 기능을 하나로 통합한다. **_componentDidMount(), componentDidUpdate(), componentWillUnmount()_**
- **_이펙트 함수 , 의존성 배열_** 을 인자로 받는다
- 의존성 배열안에 값이 변경되면 이펙트 함수가 실행
- **_처음 컴포넌트가 렌더링된 이후와 업데이트로 인한 재렌더링 이후에 실행_**

```jsx
useEffect(이펙트 함수, 의존성 배열);
```

- 의존성 배열에 **_빈 배열( [ ] )_** 을 넣으면 **_mount, unmount 시에 한 번씩만 실행_** 된다

```jsx
useEffect(이펙트 함수, []);
```

- **_의존성 배열을 생략_** 하면 **_컴포넌트 업데이트 마다 호출_** 된다

```jsx
useEffect(이펙트 함수);
```

## [7.4] useMemo

### Memoization

- 최적화를 위해 사용하는 개념
- **_연산량이 많이드는( 비용이 높은 ) 함수의 호출 결과를 저장_** 해 두었다가, 같은 입력값으로 함수를 호출하면 새로 함수를 호출하지 않고 이전 저장해놨던 호출 결과를 바로 반환 하는 것
- 함수 호출 결과를 받기까지 걸리는 시간도 짧아지고 불필요한 중복 연산도 하지 않기 때문에 컴퓨터의 자원을 적게 사용

### useMemo

- **_Memoized value_** 를 리턴하는 훅이다
- **_Memoized value : Memoization된 결과_**
- useMemo()로 전달되는 함수는 렌더링이 일어나는 동안 실행된다
- 즉, **_렌더링이 일어나는 동안 실행돼서는 안될 작업을 useMemo에 넣으면 안된다_**
- ex. 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 작업은 **_렌더링이 일어나는 동안 실행하면 안됨_** ⇒ **_useEffect_** 훅을 사용해야한다

```jsx
const memoizedValue = useMemo(() => {
  // 연산량이 높은 작업을 수행하여 결과를 반환
  return computerExpensiveValeu(의존성1, 의존성2);
}, [의존성1, 의존성2]);
```

- **_의존성 배열을 넣지 않을 경우_** , 렌더링 마다 함수가 실행
  ⇒ useMemo를 사용하는 의미가 없다

```jsx
const memoizedValue = useMemo(() => computeExpesiveValue(a, b));
```

- **_의존성 배열이 빈 배열일 경우_** , 컴포넌트 마운트 시에만 호출

```jsx
const memoizedValue = useMemo (
	() => {
		retrun computeExpesiveValue(a, b)
	},
	[]
);
```

💡 대부분의 경우 의존성 배열에 값을 넣고, 변경 시에 새로 값을 계산해야할 경우에 useMemo 훅을 사용한다

## [7.5] useCallback

### useCallback

- useMemo 훅과 유사하지만 **_값이 아닌 함수를 반환_**
- 함수와 의존성 배열을 파라미터로 받는다
- 파라미터로 받는 함수를 **_callback_** 이라고 부른다
- 의존성 배열에 있는 변수 중 하나라도 변경되면 **_Memoized 콜백 함수를 반환_** 한다

```jsx
const memoizedCallback = useCallback(
	() => {
		doSomething(의존성 변수1, 의존성변수2);
	},
	[의존성 변수1, 의존성 변수2]
);
```

- 의존성 배열에 따라 `Memoized` 값을 반환한다는 점에서 **_useMemo 훅과 완전히 동일하다_**
- 만약 **_useCallback 훅을 사용하지 않고_** 컴포넌트 내에 함수를 정의한다면 매번 렌더링이 일어날 때마다 함수가 새로 정의 되어야 한다
- 따라서 **_useCallback 훅을 사용하여 특정 변수의 값이 변한 경우에만 함수를 다시 정의_** 하도록 해서 불필요한 반복 작업을 없애주는 것이다

```jsx
useCallback(함수, 의존성 배열);
useMemo(() => 함수, 의존성 배열);
```

## [7.6] useRef

### useRef

- Reference를 사용하기 위한 훅
- Reference : 특정 컴포넌트에 접근할 수 있는 객체
- **_.current_** 라는 속성은 현재 참조하고 있는 엘리먼트를 의미
- 컴포넌트가 마운트 해제 전까지는 계속 유지된다
- **_변경 가능한 .current 속성을 가진 하나의 상자이다_**
- 매번 렌더링될 때마다 항상 같은 ref 객체를 반환한다
- 내부의 데이터가 **_변경되었을 때 별도로 알리지 않는다_**

```jsx
const refContainer = useRef(초기값);
```

## [7.7] 훅의 규칙

- 훅은 무조건 최상위 레벨에서만 호출해야한다
- 반복문이나 조건문 또는 중첩된 함수들 안에서 훅을 호출하면 안된다
- 훅은 컴포넌트가 렌더링 될 때마다 매번 같은 순서로 호출 되어야 한다
- 리액트 함수 컴포넌트에서만 훅을 호출 해야한다
